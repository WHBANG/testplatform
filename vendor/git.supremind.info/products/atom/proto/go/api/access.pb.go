// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: access.proto

package api

import (
	context "context"
	fmt "fmt"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Operation int32

const (
	// use power of 2 to make use of bitwise calculations
	Operation_None           Operation = 0
	Operation_Exec           Operation = 8
	Operation_Read           Operation = 4
	Operation_Write          Operation = 2
	Operation_Share          Operation = 1
	Operation_ReadWriteShare Operation = 7
	Operation_ReadWrite      Operation = 6
)

var Operation_name = map[int32]string{
	0: "None",
	8: "Exec",
	4: "Read",
	2: "Write",
	1: "Share",
	7: "ReadWriteShare",
	6: "ReadWrite",
}

var Operation_value = map[string]int32{
	"None":           0,
	"Exec":           8,
	"Read":           4,
	"Write":          2,
	"Share":          1,
	"ReadWriteShare": 7,
	"ReadWrite":      6,
}

func (x Operation) String() string {
	return proto.EnumName(Operation_name, int32(x))
}

func (Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{0}
}

type AccessRule struct {
	// Types that are valid to be assigned to Subject:
	//	*AccessRule_User
	//	*AccessRule_Role
	Subject   isAccessRule_Subject `protobuf_oneof:"subject"`
	Resource  *ResourceReference   `protobuf:"bytes,3,opt,name=resource,proto3" json:"resource,omitempty"`
	Operation Operation            `protobuf:"varint,4,opt,name=operation,proto3,enum=apiserver.v2.Operation" json:"operation,omitempty"`
}

func (m *AccessRule) Reset()         { *m = AccessRule{} }
func (m *AccessRule) String() string { return proto.CompactTextString(m) }
func (*AccessRule) ProtoMessage()    {}
func (*AccessRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{0}
}
func (m *AccessRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccessRule.Unmarshal(m, b)
}
func (m *AccessRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccessRule.Marshal(b, m, deterministic)
}
func (m *AccessRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessRule.Merge(m, src)
}
func (m *AccessRule) XXX_Size() int {
	return xxx_messageInfo_AccessRule.Size(m)
}
func (m *AccessRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessRule.DiscardUnknown(m)
}

var xxx_messageInfo_AccessRule proto.InternalMessageInfo

type isAccessRule_Subject interface {
	isAccessRule_Subject()
	Equal(interface{}) bool
}

type AccessRule_User struct {
	User string `protobuf:"bytes,1,opt,name=user,proto3,oneof" json:"user,omitempty"`
}
type AccessRule_Role struct {
	Role string `protobuf:"bytes,2,opt,name=role,proto3,oneof" json:"role,omitempty"`
}

func (*AccessRule_User) isAccessRule_Subject() {}
func (*AccessRule_Role) isAccessRule_Subject() {}

func (m *AccessRule) GetSubject() isAccessRule_Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *AccessRule) GetUser() string {
	if x, ok := m.GetSubject().(*AccessRule_User); ok {
		return x.User
	}
	return ""
}

func (m *AccessRule) GetRole() string {
	if x, ok := m.GetSubject().(*AccessRule_Role); ok {
		return x.Role
	}
	return ""
}

func (m *AccessRule) GetResource() *ResourceReference {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *AccessRule) GetOperation() Operation {
	if m != nil {
		return m.Operation
	}
	return Operation_None
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AccessRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AccessRule_User)(nil),
		(*AccessRule_Role)(nil),
	}
}

type GroupingRule struct {
	// Types that are valid to be assigned to Subject:
	//	*GroupingRule_User
	//	*GroupingRule_SubRole
	Subject isGroupingRule_Subject `protobuf_oneof:"subject"`
	Role    string                 `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *GroupingRule) Reset()         { *m = GroupingRule{} }
func (m *GroupingRule) String() string { return proto.CompactTextString(m) }
func (*GroupingRule) ProtoMessage()    {}
func (*GroupingRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{1}
}
func (m *GroupingRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GroupingRule.Unmarshal(m, b)
}
func (m *GroupingRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GroupingRule.Marshal(b, m, deterministic)
}
func (m *GroupingRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupingRule.Merge(m, src)
}
func (m *GroupingRule) XXX_Size() int {
	return xxx_messageInfo_GroupingRule.Size(m)
}
func (m *GroupingRule) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupingRule.DiscardUnknown(m)
}

var xxx_messageInfo_GroupingRule proto.InternalMessageInfo

type isGroupingRule_Subject interface {
	isGroupingRule_Subject()
	Equal(interface{}) bool
}

type GroupingRule_User struct {
	User string `protobuf:"bytes,1,opt,name=user,proto3,oneof" json:"user,omitempty"`
}
type GroupingRule_SubRole struct {
	SubRole string `protobuf:"bytes,2,opt,name=subRole,proto3,oneof" json:"subRole,omitempty"`
}

func (*GroupingRule_User) isGroupingRule_Subject()    {}
func (*GroupingRule_SubRole) isGroupingRule_Subject() {}

func (m *GroupingRule) GetSubject() isGroupingRule_Subject {
	if m != nil {
		return m.Subject
	}
	return nil
}

func (m *GroupingRule) GetUser() string {
	if x, ok := m.GetSubject().(*GroupingRule_User); ok {
		return x.User
	}
	return ""
}

func (m *GroupingRule) GetSubRole() string {
	if x, ok := m.GetSubject().(*GroupingRule_SubRole); ok {
		return x.SubRole
	}
	return ""
}

func (m *GroupingRule) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GroupingRule) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GroupingRule_User)(nil),
		(*GroupingRule_SubRole)(nil),
	}
}

type ListOptions struct {
	AsRole string    `protobuf:"bytes,1,opt,name=asRole,proto3" json:"asRole,omitempty"`
	Op     Operation `protobuf:"varint,2,opt,name=op,proto3,enum=apiserver.v2.Operation" json:"op,omitempty"`
}

func (m *ListOptions) Reset()         { *m = ListOptions{} }
func (m *ListOptions) String() string { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()    {}
func (*ListOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{2}
}
func (m *ListOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListOptions.Unmarshal(m, b)
}
func (m *ListOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListOptions.Marshal(b, m, deterministic)
}
func (m *ListOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOptions.Merge(m, src)
}
func (m *ListOptions) XXX_Size() int {
	return xxx_messageInfo_ListOptions.Size(m)
}
func (m *ListOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ListOptions proto.InternalMessageInfo

func (m *ListOptions) GetAsRole() string {
	if m != nil {
		return m.AsRole
	}
	return ""
}

func (m *ListOptions) GetOp() Operation {
	if m != nil {
		return m.Op
	}
	return Operation_None
}

type GrantAccessReq struct {
	Rule *AccessRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
}

func (m *GrantAccessReq) Reset()         { *m = GrantAccessReq{} }
func (m *GrantAccessReq) String() string { return proto.CompactTextString(m) }
func (*GrantAccessReq) ProtoMessage()    {}
func (*GrantAccessReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{3}
}
func (m *GrantAccessReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GrantAccessReq.Unmarshal(m, b)
}
func (m *GrantAccessReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GrantAccessReq.Marshal(b, m, deterministic)
}
func (m *GrantAccessReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GrantAccessReq.Merge(m, src)
}
func (m *GrantAccessReq) XXX_Size() int {
	return xxx_messageInfo_GrantAccessReq.Size(m)
}
func (m *GrantAccessReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GrantAccessReq.DiscardUnknown(m)
}

var xxx_messageInfo_GrantAccessReq proto.InternalMessageInfo

func (m *GrantAccessReq) GetRule() *AccessRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

type RevokeAccessReq struct {
	Rule *AccessRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty"`
}

func (m *RevokeAccessReq) Reset()         { *m = RevokeAccessReq{} }
func (m *RevokeAccessReq) String() string { return proto.CompactTextString(m) }
func (*RevokeAccessReq) ProtoMessage()    {}
func (*RevokeAccessReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{4}
}
func (m *RevokeAccessReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RevokeAccessReq.Unmarshal(m, b)
}
func (m *RevokeAccessReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RevokeAccessReq.Marshal(b, m, deterministic)
}
func (m *RevokeAccessReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevokeAccessReq.Merge(m, src)
}
func (m *RevokeAccessReq) XXX_Size() int {
	return xxx_messageInfo_RevokeAccessReq.Size(m)
}
func (m *RevokeAccessReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RevokeAccessReq.DiscardUnknown(m)
}

var xxx_messageInfo_RevokeAccessReq proto.InternalMessageInfo

func (m *RevokeAccessReq) GetRule() *AccessRule {
	if m != nil {
		return m.Rule
	}
	return nil
}

type RulesByResourceReq struct {
	Resource *ResourceReference `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
}

func (m *RulesByResourceReq) Reset()         { *m = RulesByResourceReq{} }
func (m *RulesByResourceReq) String() string { return proto.CompactTextString(m) }
func (*RulesByResourceReq) ProtoMessage()    {}
func (*RulesByResourceReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{5}
}
func (m *RulesByResourceReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RulesByResourceReq.Unmarshal(m, b)
}
func (m *RulesByResourceReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RulesByResourceReq.Marshal(b, m, deterministic)
}
func (m *RulesByResourceReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RulesByResourceReq.Merge(m, src)
}
func (m *RulesByResourceReq) XXX_Size() int {
	return xxx_messageInfo_RulesByResourceReq.Size(m)
}
func (m *RulesByResourceReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RulesByResourceReq.DiscardUnknown(m)
}

var xxx_messageInfo_RulesByResourceReq proto.InternalMessageInfo

func (m *RulesByResourceReq) GetResource() *ResourceReference {
	if m != nil {
		return m.Resource
	}
	return nil
}

type RulesByResourceRes struct {
	Rules []*AccessRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *RulesByResourceRes) Reset()         { *m = RulesByResourceRes{} }
func (m *RulesByResourceRes) String() string { return proto.CompactTextString(m) }
func (*RulesByResourceRes) ProtoMessage()    {}
func (*RulesByResourceRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{6}
}
func (m *RulesByResourceRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RulesByResourceRes.Unmarshal(m, b)
}
func (m *RulesByResourceRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RulesByResourceRes.Marshal(b, m, deterministic)
}
func (m *RulesByResourceRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RulesByResourceRes.Merge(m, src)
}
func (m *RulesByResourceRes) XXX_Size() int {
	return xxx_messageInfo_RulesByResourceRes.Size(m)
}
func (m *RulesByResourceRes) XXX_DiscardUnknown() {
	xxx_messageInfo_RulesByResourceRes.DiscardUnknown(m)
}

var xxx_messageInfo_RulesByResourceRes proto.InternalMessageInfo

func (m *RulesByResourceRes) GetRules() []*AccessRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type CheckAccessReq struct {
	Resource *ResourceReference `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
	Op       Operation          `protobuf:"varint,2,opt,name=op,proto3,enum=apiserver.v2.Operation" json:"op,omitempty"`
}

func (m *CheckAccessReq) Reset()         { *m = CheckAccessReq{} }
func (m *CheckAccessReq) String() string { return proto.CompactTextString(m) }
func (*CheckAccessReq) ProtoMessage()    {}
func (*CheckAccessReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{7}
}
func (m *CheckAccessReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckAccessReq.Unmarshal(m, b)
}
func (m *CheckAccessReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckAccessReq.Marshal(b, m, deterministic)
}
func (m *CheckAccessReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAccessReq.Merge(m, src)
}
func (m *CheckAccessReq) XXX_Size() int {
	return xxx_messageInfo_CheckAccessReq.Size(m)
}
func (m *CheckAccessReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAccessReq.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAccessReq proto.InternalMessageInfo

func (m *CheckAccessReq) GetResource() *ResourceReference {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *CheckAccessReq) GetOp() Operation {
	if m != nil {
		return m.Op
	}
	return Operation_None
}

type CheckAccessRes struct {
	Shall bool `protobuf:"varint,1,opt,name=shall,proto3" json:"shall,omitempty"`
}

func (m *CheckAccessRes) Reset()         { *m = CheckAccessRes{} }
func (m *CheckAccessRes) String() string { return proto.CompactTextString(m) }
func (*CheckAccessRes) ProtoMessage()    {}
func (*CheckAccessRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{8}
}
func (m *CheckAccessRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CheckAccessRes.Unmarshal(m, b)
}
func (m *CheckAccessRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CheckAccessRes.Marshal(b, m, deterministic)
}
func (m *CheckAccessRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckAccessRes.Merge(m, src)
}
func (m *CheckAccessRes) XXX_Size() int {
	return xxx_messageInfo_CheckAccessRes.Size(m)
}
func (m *CheckAccessRes) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckAccessRes.DiscardUnknown(m)
}

var xxx_messageInfo_CheckAccessRes proto.InternalMessageInfo

func (m *CheckAccessRes) GetShall() bool {
	if m != nil {
		return m.Shall
	}
	return false
}

type AccessToResourceReq struct {
	Resource *ResourceReference `protobuf:"bytes,1,opt,name=resource,proto3" json:"resource,omitempty"`
}

func (m *AccessToResourceReq) Reset()         { *m = AccessToResourceReq{} }
func (m *AccessToResourceReq) String() string { return proto.CompactTextString(m) }
func (*AccessToResourceReq) ProtoMessage()    {}
func (*AccessToResourceReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{9}
}
func (m *AccessToResourceReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccessToResourceReq.Unmarshal(m, b)
}
func (m *AccessToResourceReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccessToResourceReq.Marshal(b, m, deterministic)
}
func (m *AccessToResourceReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessToResourceReq.Merge(m, src)
}
func (m *AccessToResourceReq) XXX_Size() int {
	return xxx_messageInfo_AccessToResourceReq.Size(m)
}
func (m *AccessToResourceReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessToResourceReq.DiscardUnknown(m)
}

var xxx_messageInfo_AccessToResourceReq proto.InternalMessageInfo

func (m *AccessToResourceReq) GetResource() *ResourceReference {
	if m != nil {
		return m.Resource
	}
	return nil
}

type ListUsersReq struct {
	ByRole string `protobuf:"bytes,1,opt,name=byRole,proto3" json:"byRole,omitempty"`
}

func (m *ListUsersReq) Reset()         { *m = ListUsersReq{} }
func (m *ListUsersReq) String() string { return proto.CompactTextString(m) }
func (*ListUsersReq) ProtoMessage()    {}
func (*ListUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{10}
}
func (m *ListUsersReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUsersReq.Unmarshal(m, b)
}
func (m *ListUsersReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUsersReq.Marshal(b, m, deterministic)
}
func (m *ListUsersReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsersReq.Merge(m, src)
}
func (m *ListUsersReq) XXX_Size() int {
	return xxx_messageInfo_ListUsersReq.Size(m)
}
func (m *ListUsersReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsersReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsersReq proto.InternalMessageInfo

func (m *ListUsersReq) GetByRole() string {
	if m != nil {
		return m.ByRole
	}
	return ""
}

type ListUsersRes struct {
	Users []string `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
}

func (m *ListUsersRes) Reset()         { *m = ListUsersRes{} }
func (m *ListUsersRes) String() string { return proto.CompactTextString(m) }
func (*ListUsersRes) ProtoMessage()    {}
func (*ListUsersRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{11}
}
func (m *ListUsersRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListUsersRes.Unmarshal(m, b)
}
func (m *ListUsersRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListUsersRes.Marshal(b, m, deterministic)
}
func (m *ListUsersRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsersRes.Merge(m, src)
}
func (m *ListUsersRes) XXX_Size() int {
	return xxx_messageInfo_ListUsersRes.Size(m)
}
func (m *ListUsersRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsersRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsersRes proto.InternalMessageInfo

func (m *ListUsersRes) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

type ListRolesReq struct {
	WithUsers bool `protobuf:"varint,1,opt,name=withUsers,proto3" json:"withUsers,omitempty"`
}

func (m *ListRolesReq) Reset()         { *m = ListRolesReq{} }
func (m *ListRolesReq) String() string { return proto.CompactTextString(m) }
func (*ListRolesReq) ProtoMessage()    {}
func (*ListRolesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{12}
}
func (m *ListRolesReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRolesReq.Unmarshal(m, b)
}
func (m *ListRolesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRolesReq.Marshal(b, m, deterministic)
}
func (m *ListRolesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRolesReq.Merge(m, src)
}
func (m *ListRolesReq) XXX_Size() int {
	return xxx_messageInfo_ListRolesReq.Size(m)
}
func (m *ListRolesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRolesReq.DiscardUnknown(m)
}

var xxx_messageInfo_ListRolesReq proto.InternalMessageInfo

func (m *ListRolesReq) GetWithUsers() bool {
	if m != nil {
		return m.WithUsers
	}
	return false
}

type ListRolesRes struct {
	Roles []*Role `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (m *ListRolesRes) Reset()         { *m = ListRolesRes{} }
func (m *ListRolesRes) String() string { return proto.CompactTextString(m) }
func (*ListRolesRes) ProtoMessage()    {}
func (*ListRolesRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{13}
}
func (m *ListRolesRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRolesRes.Unmarshal(m, b)
}
func (m *ListRolesRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRolesRes.Marshal(b, m, deterministic)
}
func (m *ListRolesRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRolesRes.Merge(m, src)
}
func (m *ListRolesRes) XXX_Size() int {
	return xxx_messageInfo_ListRolesRes.Size(m)
}
func (m *ListRolesRes) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRolesRes.DiscardUnknown(m)
}

var xxx_messageInfo_ListRolesRes proto.InternalMessageInfo

func (m *ListRolesRes) GetRoles() []*Role {
	if m != nil {
		return m.Roles
	}
	return nil
}

type Role struct {
	Name  string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Users []string `protobuf:"bytes,2,rep,name=users,proto3" json:"users,omitempty"`
}

func (m *Role) Reset()         { *m = Role{} }
func (m *Role) String() string { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()    {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{14}
}
func (m *Role) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Role.Unmarshal(m, b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Role.Marshal(b, m, deterministic)
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return xxx_messageInfo_Role.Size(m)
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Role) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

type AssignRoleReq struct {
	*GroupingRule `protobuf:"bytes,1,opt,name=grouping,proto3,embedded=grouping" json:"grouping,omitempty"`
}

func (m *AssignRoleReq) Reset()         { *m = AssignRoleReq{} }
func (m *AssignRoleReq) String() string { return proto.CompactTextString(m) }
func (*AssignRoleReq) ProtoMessage()    {}
func (*AssignRoleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{15}
}
func (m *AssignRoleReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AssignRoleReq.Unmarshal(m, b)
}
func (m *AssignRoleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AssignRoleReq.Marshal(b, m, deterministic)
}
func (m *AssignRoleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignRoleReq.Merge(m, src)
}
func (m *AssignRoleReq) XXX_Size() int {
	return xxx_messageInfo_AssignRoleReq.Size(m)
}
func (m *AssignRoleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignRoleReq.DiscardUnknown(m)
}

var xxx_messageInfo_AssignRoleReq proto.InternalMessageInfo

type DeassignRoleReq struct {
	*GroupingRule `protobuf:"bytes,1,opt,name=grouping,proto3,embedded=grouping" json:"grouping,omitempty"`
}

func (m *DeassignRoleReq) Reset()         { *m = DeassignRoleReq{} }
func (m *DeassignRoleReq) String() string { return proto.CompactTextString(m) }
func (*DeassignRoleReq) ProtoMessage()    {}
func (*DeassignRoleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{16}
}
func (m *DeassignRoleReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeassignRoleReq.Unmarshal(m, b)
}
func (m *DeassignRoleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeassignRoleReq.Marshal(b, m, deterministic)
}
func (m *DeassignRoleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeassignRoleReq.Merge(m, src)
}
func (m *DeassignRoleReq) XXX_Size() int {
	return xxx_messageInfo_DeassignRoleReq.Size(m)
}
func (m *DeassignRoleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeassignRoleReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeassignRoleReq proto.InternalMessageInfo

type DeleteRoleReq struct {
	Role string `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
}

func (m *DeleteRoleReq) Reset()         { *m = DeleteRoleReq{} }
func (m *DeleteRoleReq) String() string { return proto.CompactTextString(m) }
func (*DeleteRoleReq) ProtoMessage()    {}
func (*DeleteRoleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a098e900d2c3a6f2, []int{17}
}
func (m *DeleteRoleReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteRoleReq.Unmarshal(m, b)
}
func (m *DeleteRoleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteRoleReq.Marshal(b, m, deterministic)
}
func (m *DeleteRoleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRoleReq.Merge(m, src)
}
func (m *DeleteRoleReq) XXX_Size() int {
	return xxx_messageInfo_DeleteRoleReq.Size(m)
}
func (m *DeleteRoleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRoleReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRoleReq proto.InternalMessageInfo

func (m *DeleteRoleReq) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func init() {
	proto.RegisterEnum("apiserver.v2.Operation", Operation_name, Operation_value)
	proto.RegisterType((*AccessRule)(nil), "apiserver.v2.AccessRule")
	proto.RegisterType((*GroupingRule)(nil), "apiserver.v2.GroupingRule")
	proto.RegisterType((*ListOptions)(nil), "apiserver.v2.ListOptions")
	proto.RegisterType((*GrantAccessReq)(nil), "apiserver.v2.GrantAccessReq")
	proto.RegisterType((*RevokeAccessReq)(nil), "apiserver.v2.RevokeAccessReq")
	proto.RegisterType((*RulesByResourceReq)(nil), "apiserver.v2.RulesByResourceReq")
	proto.RegisterType((*RulesByResourceRes)(nil), "apiserver.v2.RulesByResourceRes")
	proto.RegisterType((*CheckAccessReq)(nil), "apiserver.v2.CheckAccessReq")
	proto.RegisterType((*CheckAccessRes)(nil), "apiserver.v2.CheckAccessRes")
	proto.RegisterType((*AccessToResourceReq)(nil), "apiserver.v2.AccessToResourceReq")
	proto.RegisterType((*ListUsersReq)(nil), "apiserver.v2.ListUsersReq")
	proto.RegisterType((*ListUsersRes)(nil), "apiserver.v2.ListUsersRes")
	proto.RegisterType((*ListRolesReq)(nil), "apiserver.v2.ListRolesReq")
	proto.RegisterType((*ListRolesRes)(nil), "apiserver.v2.ListRolesRes")
	proto.RegisterType((*Role)(nil), "apiserver.v2.Role")
	proto.RegisterType((*AssignRoleReq)(nil), "apiserver.v2.AssignRoleReq")
	proto.RegisterType((*DeassignRoleReq)(nil), "apiserver.v2.DeassignRoleReq")
	proto.RegisterType((*DeleteRoleReq)(nil), "apiserver.v2.DeleteRoleReq")
}

func init() { proto.RegisterFile("access.proto", fileDescriptor_a098e900d2c3a6f2) }

var fileDescriptor_a098e900d2c3a6f2 = []byte{
	// 898 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x65, 0xc9, 0x16, 0x47, 0xb2, 0x2d, 0x4c, 0x03, 0x57, 0xa0, 0x53, 0x47, 0x65, 0x8b,
	0xd4, 0x28, 0x62, 0xaa, 0x50, 0x51, 0xa0, 0x40, 0x81, 0x06, 0x52, 0x2c, 0xa4, 0x05, 0x8a, 0x18,
	0x65, 0x6a, 0x04, 0xe8, 0x8d, 0xa2, 0xc6, 0x12, 0x1b, 0x89, 0x4b, 0xef, 0x92, 0x6a, 0xf4, 0x0a,
	0x3d, 0xe5, 0x31, 0xfa, 0x06, 0x7d, 0x8d, 0x1c, 0x7b, 0xea, 0xa1, 0x7e, 0x80, 0xde, 0x73, 0x2a,
	0x76, 0x49, 0x8a, 0x3f, 0xb1, 0xd4, 0xdf, 0xdc, 0x66, 0x76, 0xfe, 0xbe, 0xd9, 0x99, 0x6f, 0x49,
	0x68, 0x39, 0xae, 0x4b, 0x42, 0x58, 0x01, 0x67, 0x21, 0xc3, 0x96, 0x13, 0x78, 0x82, 0xf8, 0x92,
	0xb8, 0xb5, 0xec, 0x1b, 0x67, 0x53, 0x2f, 0x9c, 0x45, 0x63, 0xcb, 0x65, 0x8b, 0xde, 0x94, 0x4d,
	0x59, 0x4f, 0x39, 0x8d, 0xa3, 0x2b, 0xa5, 0x29, 0x45, 0x49, 0x71, 0xb0, 0x31, 0xc8, 0xb9, 0x93,
	0xbf, 0x64, 0xab, 0x80, 0xb3, 0x17, 0xab, 0x38, 0xc8, 0x3d, 0x9b, 0x92, 0x7f, 0xb6, 0x74, 0xe6,
	0xde, 0xc4, 0x09, 0xa9, 0xf7, 0x86, 0x90, 0xa4, 0x38, 0x9e, 0x32, 0x36, 0x9d, 0x53, 0x56, 0x88,
	0x16, 0x41, 0xb8, 0x4a, 0x8c, 0xb0, 0xa0, 0xd0, 0x89, 0x65, 0xf3, 0x17, 0x0d, 0x60, 0xa0, 0x90,
	0xdb, 0xd1, 0x9c, 0xf0, 0x0e, 0xd4, 0x22, 0x41, 0xbc, 0xa3, 0x75, 0xb5, 0x53, 0xfd, 0xab, 0x8a,
	0xad, 0x34, 0x79, 0xca, 0xd9, 0x9c, 0x3a, 0xd5, 0xf4, 0x54, 0x6a, 0xf8, 0x05, 0x34, 0x38, 0x09,
	0x16, 0x71, 0x97, 0x3a, 0x3b, 0x5d, 0xed, 0xb4, 0xd9, 0xbf, 0x67, 0xe5, 0xdb, 0xb6, 0xec, 0xc4,
	0x6a, 0xd3, 0x15, 0x71, 0xf2, 0x5d, 0xb2, 0xd7, 0x01, 0xf8, 0x19, 0xe8, 0x2c, 0x20, 0xee, 0x84,
	0x1e, 0xf3, 0x3b, 0xb5, 0xae, 0x76, 0x7a, 0xd0, 0x7f, 0xb7, 0x18, 0x7d, 0x91, 0x9a, 0xed, 0xcc,
	0x73, 0xa8, 0xc3, 0x9e, 0x88, 0xc6, 0x3f, 0x90, 0x1b, 0x9a, 0x33, 0x68, 0x3d, 0xe6, 0x2c, 0x0a,
	0x3c, 0x7f, 0xba, 0x05, 0xba, 0xa1, 0x02, 0xec, 0x3c, 0xfa, 0xf4, 0x00, 0x8f, 0x93, 0xb6, 0x24,
	0x78, 0x7d, 0xb8, 0xf7, 0x7a, 0x58, 0xe3, 0xd5, 0xb6, 0x16, 0x77, 0x97, 0xaf, 0xf4, 0x04, 0x9a,
	0xdf, 0x78, 0x22, 0xbc, 0x08, 0x24, 0x04, 0x81, 0x47, 0xb0, 0xeb, 0x08, 0x95, 0x51, 0x95, 0xb2,
	0x13, 0x0d, 0x3f, 0x82, 0x2a, 0x0b, 0x54, 0x95, 0x2d, 0xbd, 0x54, 0x59, 0x60, 0x7e, 0x09, 0x07,
	0x8f, 0xb9, 0xe3, 0x87, 0xc9, 0xbd, 0xd3, 0x35, 0x3e, 0x80, 0x1a, 0x8f, 0x92, 0x84, 0xcd, 0x7e,
	0xa7, 0x18, 0x9c, 0x8d, 0xc7, 0x56, 0x5e, 0xe6, 0x43, 0x38, 0xb4, 0x69, 0xc9, 0x9e, 0xd3, 0xbf,
	0x4d, 0xf0, 0x2d, 0xa0, 0xd4, 0xc4, 0x70, 0x95, 0x8d, 0xe8, 0xba, 0x30, 0x4f, 0xed, 0x1f, 0xce,
	0xd3, 0x3c, 0xbf, 0x25, 0xa5, 0x40, 0x0b, 0xea, 0xb2, 0xa0, 0xe8, 0x68, 0xdd, 0x9d, 0xad, 0xb8,
	0x62, 0x37, 0x73, 0x09, 0x07, 0x8f, 0x66, 0xe4, 0x3e, 0xcf, 0x1a, 0xfb, 0x2f, 0xa0, 0xfe, 0xfe,
	0x44, 0xee, 0x97, 0xea, 0x0a, 0xbc, 0x03, 0x75, 0x31, 0x73, 0xe6, 0x73, 0x55, 0xb4, 0x61, 0xc7,
	0x8a, 0x69, 0xc3, 0x3b, 0xb1, 0xcb, 0x77, 0xec, 0x7f, 0xbb, 0xb9, 0xfb, 0xd0, 0x92, 0xdb, 0x75,
	0x29, 0x88, 0xab, 0x8e, 0x8f, 0x60, 0x77, 0xbc, 0xca, 0xaf, 0x57, 0xac, 0x99, 0x1f, 0x16, 0xfc,
	0x14, 0x42, 0xb9, 0xe1, 0xf1, 0xdd, 0xea, 0x76, 0xac, 0x98, 0x0f, 0x62, 0x2f, 0x19, 0xa1, 0xb2,
	0xdd, 0x05, 0xfd, 0x47, 0x2f, 0x9c, 0x5d, 0x26, 0x9e, 0xb2, 0x97, 0xec, 0xc0, 0xfc, 0xbc, 0xe0,
	0x2d, 0xf0, 0x14, 0xea, 0x72, 0xf9, 0xd3, 0x79, 0x61, 0xa9, 0x0b, 0xa6, 0x26, 0x25, 0x1d, 0xcc,
	0x4f, 0xa0, 0xa6, 0x96, 0x1e, 0xa1, 0xe6, 0x3b, 0x8b, 0x14, 0xab, 0x92, 0x33, 0x64, 0xd5, 0x3c,
	0xb2, 0x4b, 0xd8, 0x1f, 0x08, 0xe1, 0x4d, 0x7d, 0x95, 0x86, 0xae, 0xf1, 0x1c, 0x1a, 0xd3, 0x84,
	0xc0, 0xc9, 0xad, 0x19, 0xc5, 0x7a, 0x79, 0x7a, 0x0f, 0x5b, 0xaf, 0x87, 0xf5, 0x9f, 0xb4, 0x6a,
	0x43, 0x7b, 0xf5, 0xdb, 0x3d, 0xcd, 0x5e, 0x47, 0x9a, 0xcf, 0xe0, 0xf0, 0x9c, 0x9c, 0xb7, 0x90,
	0xf8, 0x03, 0xd8, 0x3f, 0xa7, 0x39, 0x85, 0x94, 0xa6, 0xc5, 0xe4, 0xb9, 0x48, 0x5a, 0x95, 0xf2,
	0xc7, 0x63, 0xd0, 0xd7, 0x9b, 0x84, 0x0d, 0xa8, 0x3d, 0x61, 0x3e, 0xb5, 0x2b, 0x52, 0x1a, 0xbd,
	0x20, 0xb7, 0xdd, 0x90, 0x92, 0x4d, 0xce, 0xa4, 0x5d, 0x43, 0x1d, 0xea, 0xcf, 0xb8, 0x17, 0x52,
	0xbb, 0x2a, 0xc5, 0xa7, 0x33, 0x87, 0x53, 0x5b, 0x43, 0x84, 0x03, 0x69, 0x57, 0x96, 0xf8, 0x6c,
	0x0f, 0xf7, 0x41, 0x5f, 0x9f, 0xb5, 0x77, 0xfb, 0x2f, 0x77, 0x60, 0x3f, 0xde, 0xba, 0xa7, 0xc4,
	0x97, 0x9e, 0x4b, 0x38, 0x82, 0x66, 0xee, 0x01, 0xc1, 0xbb, 0xe5, 0xee, 0xf2, 0x6f, 0x8b, 0xb1,
	0x91, 0x74, 0x38, 0x82, 0x56, 0xfe, 0x1d, 0xc1, 0xf7, 0xca, 0x4b, 0x5b, 0x78, 0x63, 0x8c, 0x23,
	0x2b, 0xfe, 0xa8, 0x58, 0xe9, 0x47, 0xc5, 0x1a, 0xc9, 0x8f, 0x0a, 0x7e, 0x0d, 0xcd, 0x1c, 0x79,
	0xca, 0x68, 0x8a, 0x7c, 0x36, 0xb6, 0x59, 0x05, 0x5e, 0x40, 0xbb, 0xcc, 0x2f, 0x7c, 0xff, 0x36,
	0xfc, 0x05, 0xfe, 0x6d, 0x69, 0xf1, 0x12, 0x0e, 0x4b, 0xcf, 0x12, 0x76, 0x4b, 0x5d, 0xbe, 0xf1,
	0x10, 0x1a, 0x7f, 0xe5, 0x21, 0xfa, 0x7f, 0x54, 0x01, 0xe3, 0x2a, 0x83, 0xc9, 0xc2, 0xf3, 0xd3,
	0xb9, 0x3c, 0x02, 0x7d, 0x4d, 0x51, 0x2c, 0xed, 0x5c, 0x9e, 0xe3, 0xc6, 0x66, 0x9b, 0x48, 0x93,
	0x28, 0x4e, 0xde, 0x96, 0x24, 0xa5, 0xb6, 0xb1, 0xd9, 0x26, 0x70, 0x04, 0x90, 0x91, 0x0d, 0x8f,
	0x4b, 0xf7, 0x93, 0x67, 0x8b, 0xb1, 0x85, 0x1b, 0x72, 0x43, 0xf2, 0xe4, 0x2a, 0x6f, 0x48, 0x89,
	0x78, 0x1b, 0x37, 0x64, 0x00, 0x90, 0x51, 0xa9, 0x8c, 0xa6, 0x40, 0xb2, 0x4d, 0x29, 0x86, 0x0f,
	0x7f, 0xfe, 0xfd, 0x44, 0x7b, 0x79, 0x73, 0x52, 0x79, 0x75, 0x73, 0x52, 0xf9, 0xf5, 0xe6, 0xa4,
	0xf2, 0xbd, 0xfc, 0xa9, 0xb2, 0x44, 0x14, 0x70, 0x5a, 0x78, 0xfe, 0xc4, 0xf2, 0xfc, 0x2b, 0xf5,
	0x5f, 0x35, 0x89, 0xdc, 0x50, 0xf4, 0x9c, 0x90, 0x2d, 0x7a, 0xe9, 0x8f, 0x55, 0xcf, 0x09, 0xbc,
	0xf1, 0xae, 0xd2, 0x3e, 0xfd, 0x33, 0x00, 0x00, 0xff, 0xff, 0x4c, 0x70, 0x6c, 0xa3, 0xa8, 0x09,
	0x00, 0x00,
}

func (this *AccessRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessRule)
	if !ok {
		that2, ok := that.(AccessRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Subject == nil {
		if this.Subject != nil {
			return false
		}
	} else if this.Subject == nil {
		return false
	} else if !this.Subject.Equal(that1.Subject) {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if this.Operation != that1.Operation {
		return false
	}
	return true
}
func (this *AccessRule_User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessRule_User)
	if !ok {
		that2, ok := that.(AccessRule_User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *AccessRule_Role) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessRule_Role)
	if !ok {
		that2, ok := that.(AccessRule_Role)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *GroupingRule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupingRule)
	if !ok {
		that2, ok := that.(GroupingRule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Subject == nil {
		if this.Subject != nil {
			return false
		}
	} else if this.Subject == nil {
		return false
	} else if !this.Subject.Equal(that1.Subject) {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}
func (this *GroupingRule_User) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupingRule_User)
	if !ok {
		that2, ok := that.(GroupingRule_User)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *GroupingRule_SubRole) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupingRule_SubRole)
	if !ok {
		that2, ok := that.(GroupingRule_SubRole)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubRole != that1.SubRole {
		return false
	}
	return true
}
func (this *ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListOptions)
	if !ok {
		that2, ok := that.(ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AsRole != that1.AsRole {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	return true
}
func (this *GrantAccessReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GrantAccessReq)
	if !ok {
		that2, ok := that.(GrantAccessReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rule.Equal(that1.Rule) {
		return false
	}
	return true
}
func (this *RevokeAccessReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RevokeAccessReq)
	if !ok {
		that2, ok := that.(RevokeAccessReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rule.Equal(that1.Rule) {
		return false
	}
	return true
}
func (this *RulesByResourceReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RulesByResourceReq)
	if !ok {
		that2, ok := that.(RulesByResourceReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	return true
}
func (this *RulesByResourceRes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RulesByResourceRes)
	if !ok {
		that2, ok := that.(RulesByResourceRes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *CheckAccessReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckAccessReq)
	if !ok {
		that2, ok := that.(CheckAccessReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	return true
}
func (this *CheckAccessRes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CheckAccessRes)
	if !ok {
		that2, ok := that.(CheckAccessRes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Shall != that1.Shall {
		return false
	}
	return true
}
func (this *AccessToResourceReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccessToResourceReq)
	if !ok {
		that2, ok := that.(AccessToResourceReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Resource.Equal(that1.Resource) {
		return false
	}
	return true
}
func (this *ListUsersReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUsersReq)
	if !ok {
		that2, ok := that.(ListUsersReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ByRole != that1.ByRole {
		return false
	}
	return true
}
func (this *ListUsersRes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListUsersRes)
	if !ok {
		that2, ok := that.(ListUsersRes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Users) != len(that1.Users) {
		return false
	}
	for i := range this.Users {
		if this.Users[i] != that1.Users[i] {
			return false
		}
	}
	return true
}
func (this *ListRolesReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListRolesReq)
	if !ok {
		that2, ok := that.(ListRolesReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.WithUsers != that1.WithUsers {
		return false
	}
	return true
}
func (this *ListRolesRes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListRolesRes)
	if !ok {
		that2, ok := that.(ListRolesRes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if !this.Roles[i].Equal(that1.Roles[i]) {
			return false
		}
	}
	return true
}
func (this *Role) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Role)
	if !ok {
		that2, ok := that.(Role)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Users) != len(that1.Users) {
		return false
	}
	for i := range this.Users {
		if this.Users[i] != that1.Users[i] {
			return false
		}
	}
	return true
}
func (this *AssignRoleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AssignRoleReq)
	if !ok {
		that2, ok := that.(AssignRoleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupingRule.Equal(that1.GroupingRule) {
		return false
	}
	return true
}
func (this *DeassignRoleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeassignRoleReq)
	if !ok {
		that2, ok := that.(DeassignRoleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupingRule.Equal(that1.GroupingRule) {
		return false
	}
	return true
}
func (this *DeleteRoleReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteRoleReq)
	if !ok {
		that2, ok := that.(DeleteRoleReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AccessServiceClient is the client API for AccessService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccessServiceClient interface {
	// share resources
	GrantAccess(ctx context.Context, in *GrantAccessReq, opts ...grpc.CallOption) (*AccessRule, error)
	RevokeAccess(ctx context.Context, in *RevokeAccessReq, opts ...grpc.CallOption) (*types.Empty, error)
	// Can I do OP on RESOURCE
	CheckAccess(ctx context.Context, in *CheckAccessReq, opts ...grpc.CallOption) (*CheckAccessRes, error)
	// What can I do on RESOURCE
	AccessToResource(ctx context.Context, in *AccessToResourceReq, opts ...grpc.CallOption) (*AccessRule, error)
	// Who can do something on RESOURCE
	RulesByResource(ctx context.Context, in *RulesByResourceReq, opts ...grpc.CallOption) (*RulesByResourceRes, error)
}

type accessServiceClient struct {
	cc *grpc.ClientConn
}

func NewAccessServiceClient(cc *grpc.ClientConn) AccessServiceClient {
	return &accessServiceClient{cc}
}

func (c *accessServiceClient) GrantAccess(ctx context.Context, in *GrantAccessReq, opts ...grpc.CallOption) (*AccessRule, error) {
	out := new(AccessRule)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessService/GrantAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessServiceClient) RevokeAccess(ctx context.Context, in *RevokeAccessReq, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessService/RevokeAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessServiceClient) CheckAccess(ctx context.Context, in *CheckAccessReq, opts ...grpc.CallOption) (*CheckAccessRes, error) {
	out := new(CheckAccessRes)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessService/CheckAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessServiceClient) AccessToResource(ctx context.Context, in *AccessToResourceReq, opts ...grpc.CallOption) (*AccessRule, error) {
	out := new(AccessRule)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessService/AccessToResource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessServiceClient) RulesByResource(ctx context.Context, in *RulesByResourceReq, opts ...grpc.CallOption) (*RulesByResourceRes, error) {
	out := new(RulesByResourceRes)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessService/RulesByResource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessServiceServer is the server API for AccessService service.
type AccessServiceServer interface {
	// share resources
	GrantAccess(context.Context, *GrantAccessReq) (*AccessRule, error)
	RevokeAccess(context.Context, *RevokeAccessReq) (*types.Empty, error)
	// Can I do OP on RESOURCE
	CheckAccess(context.Context, *CheckAccessReq) (*CheckAccessRes, error)
	// What can I do on RESOURCE
	AccessToResource(context.Context, *AccessToResourceReq) (*AccessRule, error)
	// Who can do something on RESOURCE
	RulesByResource(context.Context, *RulesByResourceReq) (*RulesByResourceRes, error)
}

// UnimplementedAccessServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAccessServiceServer struct {
}

func (*UnimplementedAccessServiceServer) GrantAccess(ctx context.Context, req *GrantAccessReq) (*AccessRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantAccess not implemented")
}
func (*UnimplementedAccessServiceServer) RevokeAccess(ctx context.Context, req *RevokeAccessReq) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAccess not implemented")
}
func (*UnimplementedAccessServiceServer) CheckAccess(ctx context.Context, req *CheckAccessReq) (*CheckAccessRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckAccess not implemented")
}
func (*UnimplementedAccessServiceServer) AccessToResource(ctx context.Context, req *AccessToResourceReq) (*AccessRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessToResource not implemented")
}
func (*UnimplementedAccessServiceServer) RulesByResource(ctx context.Context, req *RulesByResourceReq) (*RulesByResourceRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RulesByResource not implemented")
}

func RegisterAccessServiceServer(s *grpc.Server, srv AccessServiceServer) {
	s.RegisterService(&_AccessService_serviceDesc, srv)
}

func _AccessService_GrantAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantAccessReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).GrantAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessService/GrantAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).GrantAccess(ctx, req.(*GrantAccessReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessService_RevokeAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeAccessReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).RevokeAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessService/RevokeAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).RevokeAccess(ctx, req.(*RevokeAccessReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessService_CheckAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAccessReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).CheckAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessService/CheckAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).CheckAccess(ctx, req.(*CheckAccessReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessService_AccessToResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToResourceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).AccessToResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessService/AccessToResource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).AccessToResource(ctx, req.(*AccessToResourceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessService_RulesByResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RulesByResourceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessServiceServer).RulesByResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessService/RulesByResource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessServiceServer).RulesByResource(ctx, req.(*RulesByResourceReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccessService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "apiserver.v2.AccessService",
	HandlerType: (*AccessServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GrantAccess",
			Handler:    _AccessService_GrantAccess_Handler,
		},
		{
			MethodName: "RevokeAccess",
			Handler:    _AccessService_RevokeAccess_Handler,
		},
		{
			MethodName: "CheckAccess",
			Handler:    _AccessService_CheckAccess_Handler,
		},
		{
			MethodName: "AccessToResource",
			Handler:    _AccessService_AccessToResource_Handler,
		},
		{
			MethodName: "RulesByResource",
			Handler:    _AccessService_RulesByResource_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "access.proto",
}

// AccessAdminServiceClient is the client API for AccessAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccessAdminServiceClient interface {
	// get all users seen by apiserver
	ListUsers(ctx context.Context, in *ListUsersReq, opts ...grpc.CallOption) (*ListUsersRes, error)
	// get all roles seen by apiserver
	ListRoles(ctx context.Context, in *ListRolesReq, opts ...grpc.CallOption) (*ListRolesRes, error)
	// user groupings
	AssignRole(ctx context.Context, in *AssignRoleReq, opts ...grpc.CallOption) (*GroupingRule, error)
	DeassignRole(ctx context.Context, in *DeassignRoleReq, opts ...grpc.CallOption) (*types.Empty, error)
	DeleteRole(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*types.Empty, error)
}

type accessAdminServiceClient struct {
	cc *grpc.ClientConn
}

func NewAccessAdminServiceClient(cc *grpc.ClientConn) AccessAdminServiceClient {
	return &accessAdminServiceClient{cc}
}

func (c *accessAdminServiceClient) ListUsers(ctx context.Context, in *ListUsersReq, opts ...grpc.CallOption) (*ListUsersRes, error) {
	out := new(ListUsersRes)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessAdminService/ListUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessAdminServiceClient) ListRoles(ctx context.Context, in *ListRolesReq, opts ...grpc.CallOption) (*ListRolesRes, error) {
	out := new(ListRolesRes)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessAdminService/ListRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessAdminServiceClient) AssignRole(ctx context.Context, in *AssignRoleReq, opts ...grpc.CallOption) (*GroupingRule, error) {
	out := new(GroupingRule)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessAdminService/AssignRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessAdminServiceClient) DeassignRole(ctx context.Context, in *DeassignRoleReq, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessAdminService/DeassignRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accessAdminServiceClient) DeleteRole(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/apiserver.v2.AccessAdminService/DeleteRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccessAdminServiceServer is the server API for AccessAdminService service.
type AccessAdminServiceServer interface {
	// get all users seen by apiserver
	ListUsers(context.Context, *ListUsersReq) (*ListUsersRes, error)
	// get all roles seen by apiserver
	ListRoles(context.Context, *ListRolesReq) (*ListRolesRes, error)
	// user groupings
	AssignRole(context.Context, *AssignRoleReq) (*GroupingRule, error)
	DeassignRole(context.Context, *DeassignRoleReq) (*types.Empty, error)
	DeleteRole(context.Context, *DeleteRoleReq) (*types.Empty, error)
}

// UnimplementedAccessAdminServiceServer can be embedded to have forward compatible implementations.
type UnimplementedAccessAdminServiceServer struct {
}

func (*UnimplementedAccessAdminServiceServer) ListUsers(ctx context.Context, req *ListUsersReq) (*ListUsersRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (*UnimplementedAccessAdminServiceServer) ListRoles(ctx context.Context, req *ListRolesReq) (*ListRolesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRoles not implemented")
}
func (*UnimplementedAccessAdminServiceServer) AssignRole(ctx context.Context, req *AssignRoleReq) (*GroupingRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignRole not implemented")
}
func (*UnimplementedAccessAdminServiceServer) DeassignRole(ctx context.Context, req *DeassignRoleReq) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeassignRole not implemented")
}
func (*UnimplementedAccessAdminServiceServer) DeleteRole(ctx context.Context, req *DeleteRoleReq) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}

func RegisterAccessAdminServiceServer(s *grpc.Server, srv AccessAdminServiceServer) {
	s.RegisterService(&_AccessAdminService_serviceDesc, srv)
}

func _AccessAdminService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessAdminServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessAdminService/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessAdminServiceServer).ListUsers(ctx, req.(*ListUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessAdminService_ListRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRolesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessAdminServiceServer).ListRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessAdminService/ListRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessAdminServiceServer).ListRoles(ctx, req.(*ListRolesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessAdminService_AssignRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessAdminServiceServer).AssignRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessAdminService/AssignRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessAdminServiceServer).AssignRole(ctx, req.(*AssignRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessAdminService_DeassignRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeassignRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessAdminServiceServer).DeassignRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessAdminService/DeassignRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessAdminServiceServer).DeassignRole(ctx, req.(*DeassignRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccessAdminService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessAdminServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/apiserver.v2.AccessAdminService/DeleteRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessAdminServiceServer).DeleteRole(ctx, req.(*DeleteRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccessAdminService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "apiserver.v2.AccessAdminService",
	HandlerType: (*AccessAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListUsers",
			Handler:    _AccessAdminService_ListUsers_Handler,
		},
		{
			MethodName: "ListRoles",
			Handler:    _AccessAdminService_ListRoles_Handler,
		},
		{
			MethodName: "AssignRole",
			Handler:    _AccessAdminService_AssignRole_Handler,
		},
		{
			MethodName: "DeassignRole",
			Handler:    _AccessAdminService_DeassignRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _AccessAdminService_DeleteRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "access.proto",
}
